package reversi.logger

trait Logger {
  /*
   * Use @elidable annotation to completely exclude functions from the compiler generated byte-code based on
   * the specified level. In a production build most logging functions will simply disappear with no runtime
   * performance penalty.
   *
   * Specify level as a compiler parameter
   * > scalac -Xelide-below INFO
  */
  def trace(msg: String, e: Exception): Unit

  def trace(msg: String): Unit

  def debug(msg: String, e: Exception): Unit

  def debug(msg: String): Unit

  def info(msg: String, e: Exception): Unit

  def info(msg: String): Unit

  def warn(msg: String, e: Exception): Unit

  def warn(msg: String): Unit

  def error(msg: String, e: Exception): Unit

  def error(msg: String): Unit

  def fatal(msg: String, e: Exception): Unit

  def fatal(msg: String): Unit

}

object LoggerFactory {

  private lazy val log4javascript: Log4JavaScript = GlobalLog4JavaScript()
  private lazy val consoleAppender: BrowserConsoleAppender = log4javascript.createBrowserConsoleAppender()
  private lazy val popupAppender: PopUpAppender = log4javascript.createPopUpAppender()

  /**
   * Create a logger that outputs to browser console
   */
  def getLogger(name: String, level: Level = null): Logger = {
    val nativeLogger = log4javascript.getLogger(name)
    nativeLogger.addAppender(consoleAppender)
    val result = new L4JSLogger(nativeLogger)
    if (level != null) result.setLevel(level)
    result
  }

  /**
   * Create a logger that outputs to a separate popup window
   */
  def getPopUpLogger(name: String, level: Level = null): Logger = {
    val nativeLogger = log4javascript.getLogger(name)
    nativeLogger.addAppender(popupAppender)
    val result = new L4JSLogger(nativeLogger)
    if (level != null) result.setLevel(level)
    result
  }
}
